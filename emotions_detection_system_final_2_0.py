# -*- coding: utf-8 -*-
"""Emotions Detection System Final 2.0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QIOaWjamrldnqUiSN-raX8PCNruJnVEw
"""

!pip install scikit-fuzzy

from google.colab import files
uploaded = files.upload()

# 🧱 Mount Google Drive
from google.colab import drive
drive.mount('/content/drive')

import zipfile
import os


# Path to the ZIP file in your Drive
zip_path = "/content/drive/MyDrive/AI_Emotion_Project/archive.zip"
extract_folder = "ravdess_data"
os.makedirs(extract_folder, exist_ok=True)

# Unzip it to the working directory
with zipfile.ZipFile(zip_path, 'r') as zip_ref:
    zip_ref.extractall(extract_folder)

print("✅ Files extracted successfully!")

import pandas as pd
import numpy as np
df = pd.read_csv('/content/ravdess_data/01-01-01-01-01-01-01.csv')
for column in df.columns:
    print(f"{column}: {df.iloc[1][column]}")

from sklearn.preprocessing import MinMaxScaler
from tqdm import tqdm

import joblib

# === Step 0: Emotion label mapping ===
emotion_map = {
    "01": "neutral",
    "02": "calm",
    "03": "happy",
    "04": "sad",
    "05": "angry",
    "06": "fearful",
    "07": "disgust",
    "08": "surprised"
}

# === Required columns for cleaning and feature extraction ===
required_columns = [
    "eye_lmk_y_43", "eye_lmk_y_47", "eye_lmk_x_42", "eye_lmk_x_45",
    "x_54", "x_48", "y_66", "y_62",
    "AU06_r", "AU12_r", "AU04_r", "AU01_r", "AU10_r", "AU09_r",
    "AU20_r", "AU14_r", "AU45_r", "AU25_r", "AU26_r",
    "pose_Rx", "pose_Ry", "pose_Rz",
    "gaze_angle_x", "gaze_angle_y"
]

# === Step 1: Clean and average middle 10 rows ===
def clean_and_average_df(df):
    df_clean = df.dropna(subset=required_columns)
    for col in required_columns:
        Q1 = df_clean[col].quantile(0.25)
        Q3 = df_clean[col].quantile(0.75)
        IQR = Q3 - Q1
        df_clean = df_clean[(df_clean[col] >= Q1 - 1.5 * IQR) & (df_clean[col] <= Q3 + 1.5 * IQR)]
    if df_clean.empty:
        return None
    mid = len(df_clean) // 2
    chunk = df_clean.iloc[max(0, mid - 5): min(len(df_clean), mid + 5)]
    return chunk.mean(numeric_only=True)

# === Step 2: Feature extraction ===
def extract_features(row):
    return {
        "eye_openness": abs(row["eye_lmk_y_43"] - row["eye_lmk_y_47"]),
        "eye_width": abs(row["eye_lmk_x_42"] - row["eye_lmk_x_45"]),
        "mouth_width": abs(row["x_54"] - row["x_48"]),
        "mouth_openness": abs(row["y_66"] - row["y_62"]),
        "AU06_r": row["AU06_r"], "AU12_r": row["AU12_r"],
        "AU04_r": row["AU04_r"], "AU01_r": row["AU01_r"],
        "AU10_r": row["AU10_r"], "AU09_r": row["AU09_r"],
        "AU20_r": row["AU20_r"], "AU14_r": row["AU14_r"],
        "AU45_r": row["AU45_r"], "AU25_r": row["AU25_r"], "AU26_r": row["AU26_r"],
        "pose_Rx": row["pose_Rx"], "pose_Ry": row["pose_Ry"], "pose_Rz": row["pose_Rz"],
        "gaze_angle_x": row["gaze_angle_x"], "gaze_angle_y": row["gaze_angle_y"]
    }

# === Step 3: Extract emotion label from filename ===
def extract_emotion_from_filename(filename):
    parts = filename.split("-")
    if len(parts) >= 3:
        emotion_code = parts[2]
        return emotion_map.get(emotion_code, "unknown")
    return "unknown"

# === Step 4: Process all CSVs and build features ===
all_features = []
for filename in tqdm(os.listdir(extract_folder)):
    if not filename.endswith(".csv"):
        continue
    try:
        df = pd.read_csv(os.path.join(extract_folder, filename))
        avg_row = clean_and_average_df(df)
        if avg_row is None or any(pd.isna(avg_row.get(col)) for col in required_columns):
            continue
        features = extract_features(avg_row)
        features["file"] = filename
        features["label"] = extract_emotion_from_filename(filename)
        all_features.append(features)
    except Exception as e:
        print(f"Error processing {filename}: {e}")

import joblib
# === Step 5: Normalize ===
features_df = pd.DataFrame(all_features)
columns_to_scale = [col for col in features_df.columns if col not in ["file", "label"]]
scaler = MinMaxScaler()
normalized = scaler.fit_transform(features_df[columns_to_scale])
normalized_df = pd.DataFrame(normalized, columns=columns_to_scale)
normalized_df["file"] = features_df["file"]
normalized_df["label"] = features_df["label"]

# === Step 6: Save results ===
joblib.dump(scaler, '/content/drive/MyDrive/AI_Emotion_Project3/minmax_scaler.pkl')
normalized_df.to_csv("normalized_features_with_labels.csv", index=False)
print("✅ Normalized features with labels saved to normalized_features_with_labels.csv")

# 📂 Path to your file in Drive
csv_path = '/content/normalized_features_with_labels.csv'

import skfuzzy as fuzz
from skfuzzy import control as ctrl

# Load and fill missing values if any
df = pd.read_csv(csv_path)


print(df.describe())

# 📥 Load the CSV and handle NaNs

df = pd.read_csv(csv_path)

# Define fuzzy input variables
mouth_openness = ctrl.Antecedent(np.linspace(0,  0.2, 100), 'mouth_openness')
eye_openness = ctrl.Antecedent(np.linspace(0,  0.2, 100), 'eye_openness')
AU06 = ctrl.Antecedent(np.linspace(0,  0.2, 100), 'AU06')
AU12 = ctrl.Antecedent(np.linspace(0,  0.2, 100), 'AU12')
AU04 = ctrl.Antecedent(np.linspace(0,  0.2, 100), 'AU04')
AU01 = ctrl.Antecedent(np.linspace(0,  0.2, 100), 'AU01')
AU45 = ctrl.Antecedent(np.linspace(0, 2.5, 100), 'AU45')  # wider range
emotion = ctrl.Consequent(np.linspace(0, 100, 100), 'emotion')

# Membership functions
for var in [mouth_openness, eye_openness, AU06, AU12, AU04, AU01]:
    var['low'] = fuzz.trimf(var.universe, [0.0, 0.0, 0.07])
    var['medium'] = fuzz.trimf(var.universe, [0.05, 0.1, 0.15])
    var['high'] = fuzz.trimf(var.universe, [0.13, 0.2, 0.2])

AU45['low'] = fuzz.trimf(AU45.universe, [0.0, 0.0, 1.0])
AU45['high'] = fuzz.trimf(AU45.universe, [1.5, 2.5, 2.5])

emotion['neutral'] = fuzz.trimf(emotion.universe, [0, 0, 25])
emotion['happy'] = fuzz.trimf(emotion.universe, [20, 40, 60])
emotion['surprised'] = fuzz.trimf(emotion.universe, [50, 70, 90])
emotion['sad'] = fuzz.trimf(emotion.universe, [70, 100, 100])

# Rules
rules = [
    ctrl.Rule(mouth_openness['high'] & eye_openness['high'], emotion['surprised']),
    ctrl.Rule(AU12['high'] & AU06['high'], emotion['happy']),
    ctrl.Rule(AU01['high'] & AU04['high'], emotion['sad']),
    ctrl.Rule(AU12['low'] & AU06['low'], emotion['neutral']),
    ctrl.Rule(AU01['medium'] & AU04['medium'], emotion['sad']),
    ctrl.Rule(eye_openness['low'] & mouth_openness['low'], emotion['neutral']),
    ctrl.Rule(AU45['high'], emotion['surprised'])
]

# Build and simulate fuzzy system
emotion_ctrl = ctrl.ControlSystem(rules)
emotion_sim = ctrl.ControlSystemSimulation(emotion_ctrl)

# Run fuzzy logic for each row
results = []
for i, row in df.iterrows():
    try:
        emotion_sim.input['mouth_openness'] = row['mouth_openness']
        emotion_sim.input['eye_openness'] = row['eye_openness']
        emotion_sim.input['AU06'] = row['AU06_r']
        emotion_sim.input['AU12'] = row['AU12_r']
        emotion_sim.input['AU04'] = row['AU04_r']
        emotion_sim.input['AU01'] = row['AU01_r']
        emotion_sim.input['AU45'] = row['AU45_r']
        emotion_sim.compute()
        results.append((row['file'], emotion_sim.output['emotion']))
    except Exception as e:
        results.append((row['file'], "Error"))

# Save results to CSV in Drive
output_df = pd.DataFrame(results, columns=["file", "emotion_score"])
output_path = "/content/drive/MyDrive/AI_Emotion_Project3/fuzzy_emotion_scores.csv"
output_df.to_csv(output_path, index=False)

print(f"✅ All done! Saved results to: {output_path}")

# Load emotion scores and features
emotion_df = pd.read_csv('/content/drive/MyDrive/AI_Emotion_Project3/fuzzy_emotion_scores.csv')
features_df = pd.read_csv('/content/normalized_features_with_labels.csv')

# 1. Extract "Error" files
error_files = emotion_df[emotion_df['emotion_score'] == 'Error']['file'].tolist()

print(f"🔍 Found {len(error_files)} files with errors.")

# 2. Review their original features
error_rows = features_df[features_df['file'].isin(error_files)]

# Show some examples with NaNs or unusual values
print("\n🔎 Example of problematic rows:")
print(error_rows.describe(include='all'))

# Load your fuzzy emotion output
fuzzy_output_path = "/content/drive/MyDrive/AI_Emotion_Project3/fuzzy_emotion_scores.csv"
df_fuzzy = pd.read_csv(fuzzy_output_path)

# Filter only the rows that had an error during fuzzy logic
df_errors = df_fuzzy[df_fuzzy['emotion_score'] == "Error"]

# Save just the filenames of problematic files
error_files = df_errors['file']
error_files_path = "/content/drive/MyDrive/AI_Emotion_Project3/error_files.csv"
error_files.to_csv(error_files_path, index=False)

print(f"✅ Saved list of {len(error_files)} error files to:\n{error_files_path}")

# Path setup
error_files_path = "/content/drive/MyDrive/AI_Emotion_Project3/error_files.csv"
extract_folder = "/content/ravdess_data"
output_path = "/content/drive/MyDrive/AI_Emotion_Project3/normalized_features_errors_fixed.csv"

# Load error filenames
error_files = pd.read_csv(error_files_path)['file'].tolist()

# Columns needed for processing
required_columns = [
    "eye_lmk_y_43", "eye_lmk_y_47", "eye_lmk_x_42", "eye_lmk_x_45",
    "x_54", "x_48", "y_66", "y_62",
    "AU06_r", "AU12_r", "AU04_r", "AU01_r", "AU10_r", "AU09_r",
    "AU20_r", "AU14_r", "AU45_r",
    "pose_Rx", "pose_Ry", "pose_Rz",
    "gaze_angle_x", "gaze_angle_y"
]

# Cleaning and averaging
def clean_and_average_df(df):
    df_clean = df.dropna(subset=required_columns)
    for col in required_columns:
        Q1 = df_clean[col].quantile(0.25)
        Q3 = df_clean[col].quantile(0.75)
        IQR = Q3 - Q1
        df_clean = df_clean[(df_clean[col] >= Q1 - 1.5 * IQR) & (df_clean[col] <= Q3 + 1.5 * IQR)]
    if df_clean.empty:
        return None
    mid = len(df_clean) // 2
    chunk = df_clean.iloc[max(0, mid - 5): min(len(df_clean), mid + 5)]
    return chunk.mean(numeric_only=True)

# Feature extraction logic
def extract_features(row):
    return {
        "eye_openness": abs(row["eye_lmk_y_43"] - row["eye_lmk_y_47"]),
        "eye_width": abs(row["eye_lmk_x_42"] - row["eye_lmk_x_45"]),
        "mouth_width": abs(row["x_54"] - row["x_48"]),
        "mouth_openness": abs(row["y_66"] - row["y_62"]),
        "AU06_r": row["AU06_r"], "AU12_r": row["AU12_r"],
        "AU04_r": row["AU04_r"], "AU01_r": row["AU01_r"],
        "AU10_r": row["AU10_r"], "AU09_r": row["AU09_r"],
        "AU20_r": row["AU20_r"], "AU14_r": row["AU14_r"],
        "AU45_r": row["AU45_r"],
        "pose_Rx": row["pose_Rx"], "pose_Ry": row["pose_Ry"], "pose_Rz": row["pose_Rz"],
        "gaze_angle_x": row["gaze_angle_x"], "gaze_angle_y": row["gaze_angle_y"]
    }

# Process each error file
fixed_features = []
for filename in tqdm(error_files, desc="Fixing error files"):
    try:
        full_path = os.path.join(extract_folder, filename)
        df = pd.read_csv(full_path)
        avg_row = clean_and_average_df(df)
        if avg_row is None or any(pd.isna(avg_row.get(col)) for col in required_columns):
            continue
        features = extract_features(avg_row)
        features["file"] = filename
        fixed_features.append(features)
    except Exception as e:
        print(f"❌ Error fixing {filename}: {e}")

# Normalize fixed features
if fixed_features:
    fixed_df = pd.DataFrame(fixed_features)
    columns_to_scale = [col for col in fixed_df.columns if col != "file"]
    scaler = MinMaxScaler()
    normalized = scaler.fit_transform(fixed_df[columns_to_scale])
    normalized_df = pd.DataFrame(normalized, columns=columns_to_scale)
    normalized_df["file"] = fixed_df["file"]
    normalized_df.to_csv(output_path, index=False)
    print(f"✅ Fixed and saved {len(normalized_df)} files to {output_path}")
else:
    print("⚠️ No valid files were recovered.")

# Load cleaned + normalized dataset
csv_path = "/content/drive/MyDrive/AI_Emotion_Project3/normalized_features_errors_fixed.csv"
df = pd.read_csv(csv_path)

# Define fuzzy input variables
mouth_openness = ctrl.Antecedent(np.linspace(0,  0.2, 100), 'mouth_openness')
eye_openness = ctrl.Antecedent(np.linspace(0,  0.2, 100), 'eye_openness')
AU06 = ctrl.Antecedent(np.linspace(0,  0.2, 100), 'AU06')
AU12 = ctrl.Antecedent(np.linspace(0,  0.2, 100), 'AU12')
AU04 = ctrl.Antecedent(np.linspace(0,  0.2, 100), 'AU04')
AU01 = ctrl.Antecedent(np.linspace(0,  0.2, 100), 'AU01')
AU45 = ctrl.Antecedent(np.linspace(0, 2.5, 100), 'AU45')
emotion = ctrl.Consequent(np.linspace(0, 100, 100), 'emotion')

# Membership functions
for var in [mouth_openness, eye_openness, AU06, AU12, AU04, AU01]:
    var['low'] = fuzz.trimf(var.universe, [0.0, 0.0, 0.07])
    var['medium'] = fuzz.trimf(var.universe, [0.05, 0.1, 0.15])
    var['high'] = fuzz.trimf(var.universe, [0.13, 0.2, 0.2])

AU45['low'] = fuzz.trimf(AU45.universe, [0.0, 0.0, 1.0])
AU45['high'] = fuzz.trimf(AU45.universe, [1.5, 2.5, 2.5])

emotion['neutral'] = fuzz.trimf(emotion.universe, [0, 0, 25])
emotion['happy'] = fuzz.trimf(emotion.universe, [20, 40, 60])
emotion['surprised'] = fuzz.trimf(emotion.universe, [50, 70, 90])
emotion['sad'] = fuzz.trimf(emotion.universe, [70, 100, 100])

# Define rules
rules = [
    ctrl.Rule(mouth_openness['high'] & eye_openness['high'], emotion['surprised']),
    ctrl.Rule(AU12['high'] & AU06['high'], emotion['happy']),
    ctrl.Rule(AU01['high'] & AU04['high'], emotion['sad']),
    ctrl.Rule(AU12['low'] & AU06['low'], emotion['neutral']),
    ctrl.Rule(AU01['medium'] & AU04['medium'], emotion['sad']),
    ctrl.Rule(eye_openness['low'] & mouth_openness['low'], emotion['neutral']),
    ctrl.Rule(AU45['high'], emotion['surprised'])
]

# Build and simulate fuzzy system
emotion_ctrl = ctrl.ControlSystem(rules)
emotion_sim = ctrl.ControlSystemSimulation(emotion_ctrl)

# Run fuzzy logic for each row
results = []
for i, row in df.iterrows():
    try:
        emotion_sim.input['mouth_openness'] = row['mouth_openness']
        emotion_sim.input['eye_openness'] = row['eye_openness']
        emotion_sim.input['AU06'] = row['AU06_r']
        emotion_sim.input['AU12'] = row['AU12_r']
        emotion_sim.input['AU04'] = row['AU04_r']
        emotion_sim.input['AU01'] = row['AU01_r']
        emotion_sim.input['AU45'] = row['AU45_r']
        emotion_sim.compute()
        results.append((row['file'], emotion_sim.output['emotion']))
    except Exception as e:
        results.append((row['file'], "Error"))

# Save results
output_path = "/content/drive/MyDrive/AI_Emotion_Project3/fuzzy_emotion_scores_errors_fixed.csv"
output_df = pd.DataFrame(results, columns=["file", "emotion_score"])
output_df.to_csv(output_path, index=False)

print(f"✅ Fuzzy emotion scores saved to: {output_path}")

# Load the normalized fixed features
csv_path = "/content/drive/MyDrive/AI_Emotion_Project3/normalized_features_errors_fixed.csv"
df = pd.read_csv(csv_path)

# Drop rows with any NaNs to avoid compute errors
df = df.dropna()

# Define fuzzy input variables
mouth_openness = ctrl.Antecedent(np.linspace(0, 0.2, 100), 'mouth_openness')
eye_openness = ctrl.Antecedent(np.linspace(0, 0.2, 100), 'eye_openness')
AU06 = ctrl.Antecedent(np.linspace(0, 0.2, 100), 'AU06')
AU12 = ctrl.Antecedent(np.linspace(0, 0.2, 100), 'AU12')
AU04 = ctrl.Antecedent(np.linspace(0, 0.2, 100), 'AU04')
AU01 = ctrl.Antecedent(np.linspace(0, 0.2, 100), 'AU01')
AU45 = ctrl.Antecedent(np.linspace(0, 2.5, 100), 'AU45')
emotion = ctrl.Consequent(np.linspace(0, 100, 100), 'emotion')

# Membership functions
for var in [mouth_openness, eye_openness, AU06, AU12, AU04, AU01]:
    var['low'] = fuzz.trimf(var.universe, [0.0, 0.0, 0.07])
    var['medium'] = fuzz.trimf(var.universe, [0.05, 0.1, 0.15])
    var['high'] = fuzz.trimf(var.universe, [0.13, 0.2, 0.2])

AU45['low'] = fuzz.trimf(AU45.universe, [0.0, 0.0, 1.0])
AU45['high'] = fuzz.trimf(AU45.universe, [1.5, 2.5, 2.5])

emotion['neutral'] = fuzz.trimf(emotion.universe, [0, 0, 25])
emotion['happy'] = fuzz.trimf(emotion.universe, [20, 40, 60])
emotion['surprised'] = fuzz.trimf(emotion.universe, [50, 70, 90])
emotion['sad'] = fuzz.trimf(emotion.universe, [70, 100, 100])

# Define rules
rules = [
    ctrl.Rule(mouth_openness['high'] & eye_openness['high'], emotion['surprised']),
    ctrl.Rule(AU12['high'] & AU06['high'], emotion['happy']),
    ctrl.Rule(AU01['high'] & AU04['high'], emotion['sad']),
    ctrl.Rule(AU12['low'] & AU06['low'], emotion['neutral']),
    ctrl.Rule(AU01['medium'] & AU04['medium'], emotion['sad']),
    ctrl.Rule(eye_openness['low'] & mouth_openness['low'], emotion['neutral']),
    ctrl.Rule(AU45['high'], emotion['surprised'])
]

# Build fuzzy system
emotion_ctrl = ctrl.ControlSystem(rules)
emotion_sim = ctrl.ControlSystemSimulation(emotion_ctrl)

# Process each row
results = []

for _, row in df.iterrows():
    try:
        emotion_sim.input['mouth_openness'] = row['mouth_openness']
        emotion_sim.input['eye_openness'] = row['eye_openness']
        emotion_sim.input['AU06'] = row['AU06_r']
        emotion_sim.input['AU12'] = row['AU12_r']
        emotion_sim.input['AU04'] = row['AU04_r']
        emotion_sim.input['AU01'] = row['AU01_r']
        emotion_sim.input['AU45'] = row['AU45_r']

        emotion_sim.compute()
        score = emotion_sim.output['emotion']
        results.append((row['file'], score))
    except Exception as e:
        results.append((row['file'], "Error"))

# Save results
output_df = pd.DataFrame(results, columns=["file", "emotion_score"])
output_path = "/content/drive/MyDrive/AI_Emotion_Project3/fuzzy_emotion_scores_errors_fixed_2.0.csv"
output_df.to_csv(output_path, index=False)

print(f"✅ Fuzzy emotion scores saved to: {output_path}")

# Load original fuzzy emotion scores
input_path = "/content/drive/MyDrive/AI_Emotion_Project3/fuzzy_emotion_scores.csv"
df = pd.read_csv(input_path)

# Drop rows where emotion_score is "Error"
clean_df = df[df["emotion_score"] != "Error"]

# Optional: convert emotion_score to float for modeling (if needed)
clean_df["emotion_score"] = clean_df["emotion_score"].astype(float)

# Save cleaned CSV
output_path = "/content/drive/MyDrive/AI_Emotion_Project3/fuzzy_emotion_scores_large.csv"
clean_df.to_csv(output_path, index=False)

print(f"✅ Cleaned file saved to: {output_path}")
print(f"🧹 Dropped {len(df) - len(clean_df)} error rows. Final rows: {len(clean_df)}")

input_path2 = "/content/drive/MyDrive/AI_Emotion_Project3/fuzzy_emotion_scores_errors_fixed_2.0.csv"
df = pd.read_csv(input_path2)

# Drop rows where emotion_score is "Error"
clean_df = df[df["emotion_score"] != "Error"]

# Optional: convert emotion_score to float for modeling (if needed)
clean_df["emotion_score"] = clean_df["emotion_score"].astype(float)

# Save cleaned CSV
output_path = "/content/drive/MyDrive/AI_Emotion_Project3/fuzzy_emotion_scores_small.csv"
clean_df.to_csv(output_path, index=False)

print(f"✅ Cleaned file saved to: {output_path}")

# Load original and fixed CSVs
original_df = pd.read_csv("/content/drive/MyDrive/AI_Emotion_Project3/fuzzy_emotion_scores_large.csv")
fixed_df = pd.read_csv("/content/drive/MyDrive/AI_Emotion_Project3/fuzzy_emotion_scores_small.csv")

# Remove the old error rows from the original file
# Assumes 'file' column identifies each row uniquely
cleaned_original_df = original_df[~original_df['file'].isin(fixed_df['file'])]

# Append the fixed rows
final_df = pd.concat([cleaned_original_df, fixed_df], ignore_index=True)

# Sort if needed
final_df = final_df.sort_values("file").reset_index(drop=True)

# Save the updated file
final_df.to_csv("/content/drive/MyDrive/AI_Emotion_Project3/scores_final.csv", index=False)
print("✅ Updated dataset saved as fuzzy_emotion_scores_final.csv")

def classify_emotion(row):
    score = row['emotion_score']
    au06 = row.get('AU06_r', 0)
    au12 = row.get('AU12_r', 0)
    au01 = row.get('AU01_r', 0)
    au04 = row.get('AU04_r', 0)
    au45 = row.get('AU45_r', 0)

    if score < 20:
        return "neutral"
    elif score < 35:
        return "calm"
    elif score < 50:
        return "happy"
    elif score < 65 and (au06 > 0.4 or au12 > 0.4):
        return "excited"
    elif score < 80:
        return "surprised"
    elif score < 90 and au45 > 2:
        return "shocked"
    elif score >= 90 and (au01 > 0.4 or au04 > 0.4):
        return "sad"
    elif score > 85 and all(val < 0.2 for val in [au06, au12, au01, au04, au45]):
        return "angry"

    else:
        return "unknown"

# Load final fuzzy scores file
df = pd.read_csv("/content/drive/MyDrive/AI_Emotion_Project3/scores_final.csv")



# Apply emotion classification
df['emotion_label'] = df.apply(classify_emotion, axis=1)

# Save the result
df.to_csv("/content/drive/MyDrive/AI_Emotion_Project3/fuzzy_emotion_labeled_extended.csv", index=False)

from google.colab import files
uploaded = files.upload()

from sklearn.metrics import classification_report

# === Load scaler and reference data ===
scaler = joblib.load("/content/drive/MyDrive/AI_Emotion_Project3/minmax_scaler.pkl")
reference_df = pd.read_csv("/content/normalized_features_with_labels.csv")

# === Define fuzzy variables ===
mouth_openness = ctrl.Antecedent(np.linspace(0, 0.2, 100), 'mouth_openness')
eye_openness = ctrl.Antecedent(np.linspace(0, 0.2, 100), 'eye_openness')
AU12 = ctrl.Antecedent(np.linspace(0, 0.2, 100), 'AU12')
AU06 = ctrl.Antecedent(np.linspace(0, 0.2, 100), 'AU06')
AU04 = ctrl.Antecedent(np.linspace(0, 0.2, 100), 'AU04')
AU01 = ctrl.Antecedent(np.linspace(0, 0.2, 100), 'AU01')
AU09 = ctrl.Antecedent(np.linspace(0, 0.2, 100), 'AU09')
AU10 = ctrl.Antecedent(np.linspace(0, 0.2, 100), 'AU10')

emotion = ctrl.Consequent(np.linspace(0, 100, 100), 'emotion')

for var in [mouth_openness, eye_openness, AU12, AU06, AU04, AU01, AU09, AU10]:
    var['low'] = fuzz.trimf(var.universe, [0.0, 0.0, 0.05])
    var['medium'] = fuzz.trimf(var.universe, [0.04, 0.08, 0.12])
    var['high'] = fuzz.trimf(var.universe, [0.1, 0.2, 0.2])

emotion['neutral'] = fuzz.trimf(emotion.universe, [0, 0, 15])
emotion['happy'] = fuzz.trimf(emotion.universe, [15, 25, 35])
emotion['disgust'] = fuzz.trimf(emotion.universe, [35, 50, 65])
emotion['surprised'] = fuzz.trimf(emotion.universe, [65, 80, 90])
emotion['angry'] = fuzz.trimf(emotion.universe, [90, 100, 100])

# === Rules ===
rules = [
    ctrl.Rule(AU12['high'] & AU06['high'] & mouth_openness['high'], emotion['happy']),
    ctrl.Rule(AU04['high'] & AU01['low'], emotion['angry']),
    ctrl.Rule(AU12['low'] & AU06['low'] & AU04['low'] & AU01['low'], emotion['neutral']),
    ctrl.Rule(AU09['high'] & AU10['medium'], emotion['disgust']),
    ctrl.Rule(mouth_openness['medium'] & eye_openness['medium'], emotion['surprised'])
]

emotion_ctrl = ctrl.ControlSystem(rules)
emotion_sim = ctrl.ControlSystemSimulation(emotion_ctrl)

# === Feature extraction ===
def extract_features(row):
    return {
        "eye_openness": abs(row["eye_lmk_y_43"] - row["eye_lmk_y_47"]),
        "mouth_openness": abs(row["y_66"] - row["y_62"]),
        "AU06_r": row["AU06_r"], "AU12_r": row["AU12_r"],
        "AU04_r": row["AU04_r"], "AU01_r": row["AU01_r"],
        "AU10_r": row["AU10_r"], "AU09_r": row["AU09_r"]
    }

# === Emotion classification ===
def classify_emotion(score):
    if score < 15:
        return "neutral"
    elif score < 35:
        return "happy"
    elif score < 65:
        return "disgust"
    elif score < 90:
        return "surprised"
    else:
        return "angry"

# === Evaluate on reference dataset ===
pred_labels = []
true_labels = []

for _, row in reference_df.iterrows():
    try:
        feats = {key: row[key] for key in reference_df.columns if key not in ["file", "label"]}
        raw_df = pd.DataFrame([feats])
        inv_scaled = scaler.inverse_transform(raw_df)
        raw_feats = dict(zip(raw_df.columns, inv_scaled[0]))

        emotion_sim.input['mouth_openness'] = feats['mouth_openness']
        emotion_sim.input['eye_openness'] = feats['eye_openness']
        emotion_sim.input['AU06'] = feats['AU06_r']
        emotion_sim.input['AU12'] = feats['AU12_r']
        emotion_sim.input['AU04'] = feats['AU04_r']
        emotion_sim.input['AU01'] = feats['AU01_r']
        emotion_sim.input['AU09'] = feats['AU09_r']
        emotion_sim.input['AU10'] = feats['AU10_r']

        emotion_sim.compute()
        score = emotion_sim.output['emotion']

        label = classify_emotion(score)
        pred_labels.append(label)
        true_labels.append(row["label"])

    except Exception as e:
        continue

# === Evaluation ===
print("\n🔍 Evaluation Report on 2400+ Labeled Files:")
print(classification_report(true_labels, pred_labels))

from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix
import joblib

# Load your dataset
data = pd.read_csv('/content/normalized_features_with_labels.csv')  # Replace with your correct filename

# Separate features and target
X = data.drop(columns=['file', 'label'])  # Drop filename and target column
y = data['label']

# Train/test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)

# Apply class_weight='balanced' to fix class imbalance
model = RandomForestClassifier(n_estimators=150, class_weight='balanced', random_state=42)
model.fit(X_train, y_train)

# Predict and evaluate
y_pred = model.predict(X_test)

print("Classification Report:")
print(classification_report(y_test, y_pred))

print("\nConfusion Matrix:")
print(confusion_matrix(y_test, y_pred))

# Save model
joblib.dump(model, 'fuzzy_emotion_rf_balanced2.pkl')

import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import confusion_matrix

# Define your true and predicted labels
y_true = y_test
y_pred = model.predict(X_test)

# Define class labels in order (make sure they match your actual label encoding!)
labels = ['angry', 'calm', 'disgust', 'fearful', 'happy', 'neutral', 'sad', 'surprised']

# Generate confusion matrix
cm = confusion_matrix(y_true, y_pred, labels=labels)

# Plot
plt.figure(figsize=(5, 4))
sns.heatmap(cm, annot=True, fmt="d", cmap="Blues", xticklabels=labels, yticklabels=labels)
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.title("Confusion Matrix with Emotion Labels")
plt.tight_layout()
plt.show()

import warnings
warnings.filterwarnings("ignore", category=UserWarning)

# === Load webcam CSV ===
df = pd.read_csv("/content/surprised sad confused crying.csv")
df.columns = df.columns.str.strip()

required_columns = [
    "timestamp",
    "eye_lmk_y_43", "eye_lmk_y_47", "eye_lmk_x_42", "eye_lmk_x_45",
    "x_54", "x_48", "y_66", "y_62",
    "AU06_r", "AU12_r", "AU04_r", "AU01_r", "AU10_r",
    "AU09_r", "AU20_r", "AU14_r",
    "AU45_r", "AU25_r", "AU26_r",
    "pose_Rx", "pose_Ry", "pose_Rz",
    "gaze_angle_x", "gaze_angle_y"
]
df = df.dropna(subset=required_columns)

def extract_features(row):
    return {
        "eye_openness": abs(row["eye_lmk_y_43"] - row["eye_lmk_y_47"]),
        "eye_width": abs(row["eye_lmk_x_42"] - row["eye_lmk_x_45"]),
        "mouth_width": abs(row["x_54"] - row["x_48"]),
        "mouth_openness": abs(row["y_66"] - row["y_62"]),
        "AU06_r": row["AU06_r"], "AU12_r": row["AU12_r"],
        "AU04_r": row["AU04_r"], "AU01_r": row["AU01_r"],
        "AU10_r": row["AU10_r"], "AU09_r": row["AU09_r"],
        "AU20_r": row["AU20_r"], "AU14_r": row["AU14_r"],
        "AU45_r": row["AU45_r"], "AU25_r": row["AU25_r"], "AU26_r": row["AU26_r"],
        "pose_Rx": row["pose_Rx"], "pose_Ry": row["pose_Ry"], "pose_Rz": row["pose_Rz"],
        "gaze_angle_x": row["gaze_angle_x"], "gaze_angle_y": row["gaze_angle_y"]
    }

# Load model and scaler
scaler = joblib.load("/content/drive/MyDrive/AI_Emotion_Project3/minmax_scaler.pkl")
model = joblib.load("fuzzy_emotion_rf_balanced2.pkl")

# === Print timestamp → emotion ===
for _, row in df.iterrows():
    try:
        feats = extract_features(row)
        scaled = scaler.transform(pd.DataFrame([feats]))
        predicted = model.predict(scaled)[0]
        print(f"{round(row['timestamp'], 2)}s → {predicted}")
    except:
        continue

# === Load OpenFace data ===
df = pd.read_csv("/content/surprised sad confused crying.csv")
df.columns = df.columns.str.strip()

# === Compute Eye Aspect Ratio (EAR) ===
def compute_eye_aspect_ratio(eye_indices, df):
    x_cols = [f'x_{i}' for i in eye_indices]
    y_cols = [f'y_{i}' for i in eye_indices]
    x_coords = df[x_cols].values
    y_coords = df[y_cols].values
    v1 = np.linalg.norm(np.stack([x_coords[:, 1] - x_coords[:, 5], y_coords[:, 1] - y_coords[:, 5]], axis=1), axis=1)
    v2 = np.linalg.norm(np.stack([x_coords[:, 2] - x_coords[:, 4], y_coords[:, 2] - y_coords[:, 4]], axis=1), axis=1)
    h = np.linalg.norm(np.stack([x_coords[:, 0] - x_coords[:, 3], y_coords[:, 0] - y_coords[:, 3]], axis=1), axis=1)
    return (v1 + v2) / (2.0 * h)

# Dlib 68-point indices for eyes
left_eye_indices = [36, 37, 38, 39, 40, 41]
right_eye_indices = [42, 43, 44, 45, 46, 47]
left_ear = compute_eye_aspect_ratio(left_eye_indices, df)
right_ear = compute_eye_aspect_ratio(right_eye_indices, df)
df['eye_openness'] = (left_ear + right_ear) / 2.0

# === Extract and normalize key features ===
features = ['AU06_r', 'AU12_r', 'AU01_r', 'AU04_r', 'AU45_r', 'eye_openness']
df = df.dropna(subset=features)  # Drop rows with missing values
data = df[features]
norm_data = (data - data.min()) / (data.max() - data.min())  # Min-max normalization

# === Define fuzzy variables ===
AU06 = ctrl.Antecedent(np.linspace(0, 1, 100), 'AU06')
AU12 = ctrl.Antecedent(np.linspace(0, 1, 100), 'AU12')
AU01 = ctrl.Antecedent(np.linspace(0, 1, 100), 'AU01')
AU04 = ctrl.Antecedent(np.linspace(0, 1, 100), 'AU04')
AU45 = ctrl.Antecedent(np.linspace(0, 1, 100), 'AU45')
eye_open = ctrl.Antecedent(np.linspace(0, 1, 100), 'eye_open')
emotion = ctrl.Consequent(np.linspace(0, 100, 100), 'emotion')

# Define membership functions
for au in [AU06, AU12, AU01, AU04, AU45, eye_open]:
    au['low'] = fuzz.trimf(au.universe, [0, 0, 0.5])
    au['high'] = fuzz.trimf(au.universe, [0.3, 1, 1])

emotion['neutral'] = fuzz.trimf(emotion.universe, [0, 0, 20])
emotion['happy'] = fuzz.trimf(emotion.universe, [20, 30, 40])
emotion['sad'] = fuzz.trimf(emotion.universe, [40, 50, 60])
emotion['surprised'] = fuzz.trimf(emotion.universe, [60, 70, 80])
emotion['angry'] = fuzz.trimf(emotion.universe, [80, 90, 100])

# === Define fuzzy rules ===
rules = [
    ctrl.Rule(AU06['high'] & AU12['high'], emotion['happy']),
    ctrl.Rule(AU01['high'] & AU04['high'], emotion['sad']),
    ctrl.Rule(AU04['high'] & AU12['low'], emotion['angry']),
    ctrl.Rule(AU01['high'] & AU45['high'] & eye_open['high'], emotion['surprised']),
    ctrl.Rule(AU06['low'] & AU12['low'] & AU04['low'], emotion['neutral']),
]

# === Build and simulate fuzzy system ===
emotion_ctrl = ctrl.ControlSystem(rules)
emotion_sim = ctrl.ControlSystemSimulation(emotion_ctrl)

# Run prediction for each frame
predicted_emotions = []
for _, row in norm_data.iterrows():
    emotion_sim.input['AU06'] = row['AU06_r']
    emotion_sim.input['AU12'] = row['AU12_r']
    emotion_sim.input['AU01'] = row['AU01_r']
    emotion_sim.input['AU04'] = row['AU04_r']
    emotion_sim.input['AU45'] = row['AU45_r']
    emotion_sim.input['eye_open'] = row['eye_openness']
    try:
        emotion_sim.compute()
        fuzzy_val = emotion_sim.output['emotion']
        if fuzzy_val < 20:
            pred = 'neutral'
        elif fuzzy_val < 40:
            pred = 'happy'
        elif fuzzy_val < 60:
            pred = 'sad'
        elif fuzzy_val < 80:
            pred = 'surprised'
        else:
            pred = 'angry'
        predicted_emotions.append(pred)
    except:
        predicted_emotions.append('calm')

# Add predictions to DataFrame
df = df.loc[norm_data.index]  # Align with normalized rows
df['predicted_emotion'] = predicted_emotions

# Only print timestamp and detected emotion, suppress everything else
import sys
import os

# Redirect stderr to null to suppress unwanted errors/warnings
sys.stderr = open(os.devnull, 'w')

# Print timestamp and emotion only
for _, row in df.iterrows():
    print(f"{row['timestamp']:.2f}: {row['predicted_emotion']}")